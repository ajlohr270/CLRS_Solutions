\documentclass{article}
\usepackage{fancyhdr}
\usepackage{amsthm}
\usepackage{etoolbox}
\usepackage{verbatim}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}


	
\pagestyle{fancy}
\title{Chapter 10}
\author{Michelle Bodnar, Andrew Lohr}

\newcounter{curnum}
\setcounter{curnum}{0}

\newtheorem{th1}{Exercise}
\newcommand{\calH}{\mathcal{H}}
\newcommand{\calX}{\mathcal{X}}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\calY}{\mathcal{Y}}

\begin{document}
\maketitle

\noindent\textbf{ Exercise 10.1-1} \\
$
\begin{array}{|c|c|c|}
\hline
4&&\\
\hline
4&1&\\
\hline
4&1&3\\
\hline
4&1&\\
\hline
4&1&8\\
\hline
4&1&\\
\hline
\end{array}
$


\noindent\textbf{ Exercise 10.1-3} \\
$
\begin{array}{|c|c|c|c|}
\hline
4&&&\\
\hline
4&1&&\\
\hline
4&1&3&\\
\hline
&1&3&\\
\hline
&1&3&8\\
\hline
&&3&8\\
\hline
\end{array}
$



\noindent\textbf{ Exercise 10.1-5} \\
As in the example code given in the section, we will neglect to check for overflow and underflow errors.

\begin{algorithm}
\caption{HEAD-ENQUEUE(Q,x)}
\begin{algorithmic}
\State $Q[Q.head] = x$
\If{$Q.head == 1$}
\State $Q.head = Q.length$
\Else
\State $Q.head = Q.head-1$
\EndIf
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{TAIL-ENQUEUE(Q,x)}
\begin{algorithmic}
\State $Q[Q.tail] = x$
\If{$Q.tail == Q.length$}
\State $Q.tail = 1$
\Else
\State $Q.tail = Q.tail+1$
\EndIf
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{HEAD-DEQUEUE(Q,x)}
\begin{algorithmic}
\State $x = Q[Q.head] $
\If{$Q.head == Q.length$}
\State $Q.head = 1$
\Else
\State $Q.head = Q.head+1$
\EndIf
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{TAIL-DEQUEUE(Q,x)}
\begin{algorithmic}
\State $x = Q[Q.tail]$
\If{$Q.tail == 1$}
\State $Q.tail = Q.length$
\Else
\State $Q.tail = Q.tail-1$
\EndIf
\end{algorithmic}
\end{algorithm}



\noindent\textbf{ Exercise 10.1-7} \\
The following is a way of implementing a stack using two queues, where pop takes linear time, and push takes constant time. The first of these ways, consists of just enqueueing each element as you push it. Then, to do a pop, you dequque each element from one of the queues and place it in the other, but stopping just before the last element. Then, return the single element left in the original queue.\\



\noindent\textbf{ Exercise 10.2-1} \\
To insert an element in constant time, just add it to the head by making it point to the old head and have it be the head. To delete an element, it needs linear time because there is no way to get a pointer to the previous element in the list without starting at the head and scanning along.\\


\noindent\textbf{ Exercise 10.2-3} \\
In addition to the head, also keep a pointer to the last element in the linked list. To enqueue, insert the element after the last element of the list, and set it to be the new last element. To dequeue, delete the first element of the list and return it.\\

\noindent\textbf{ Exercise 10.2-5} \\
To insert, just do list insert before the current head, in constant time. To search, start at the head, check if the element is the current node being inspected, check the next element, and so on until at the end of the list or you found the element. This can take linear time in the worst case. To delete, again linear time is used because there is no way to get to the element immediately before the current element without starting at the head and going along the list.\\

\noindent\textbf{ Exercise 10.2-7} \\
\begin{algorithm}
\caption{REVERSE(L)}
\begin{algorithmic}
\State $a = L.head.next$
\State $b = L.head$
\While{$a\neq NIL$}
\State $tmp = a.next$
\State $a.next = b$
\State $b = a$
\State $a= tmp$
\EndWhile
\State $L.head  = b$
\end{algorithmic}
\end{algorithm}


\noindent\textbf{ Exercise 10.3-1} \\

\noindent\textbf{ Exercise 10.3-3} \\

\noindent\textbf{ Exercise 10.3-5} \\

\noindent\textbf{ Exercise 10.4-1} \\

\noindent\textbf{ Exercise 10.4-3} \\

\noindent\textbf{ Exercise 10.4-5} \\

\noindent\textbf{ Problem 10-1} \\

\noindent\textbf{ Problem 10-3} \\


\end{document} 